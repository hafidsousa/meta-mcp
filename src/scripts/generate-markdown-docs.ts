#!/usr/bin/env node

/**
 * @fileoverview Script to generate Markdown documentation from tool definitions
 * 
 * This script reads the tools.json file generated by the docgen utility
 * and creates human-readable Markdown documentation for each tool category.
 * 
 * Usage: 
 * - npm run generate-markdown-docs
 */

import fs from 'fs';
import path from 'path';

interface SchemaProperty {
  type: string;
  description?: string;
  enum?: string[];
  default?: any;
  items?: any;
  properties?: Record<string, SchemaProperty>;
  required?: string[];
}

interface Tool {
  name: string;
  description: string;
  inputSchema: {
    type: string;
    properties?: Record<string, SchemaProperty>;
    required?: string[];
  };
}

// Helper function to create a Markdown table from schema properties
function createSchemaTable(properties: Record<string, SchemaProperty>, required: string[] = []): string {
  if (!properties) return 'No parameters required.';
  
  let table = '| Parameter | Type | Required | Description |\n';
  table += '|-----------|------|----------|-------------|\n';
  
  Object.entries(properties).forEach(([name, prop]) => {
    const isRequired = required.includes(name) ? 'Yes' : 'No';
    const type = prop.enum 
      ? `${prop.type} (enum: ${prop.enum.join(', ')})`
      : prop.type;
    const description = prop.description || '';
    
    table += `| \`${name}\` | ${type} | ${isRequired} | ${description} |\n`;
  });
  
  return table;
}

// Helper function to create nested property documentation
function createNestedPropertyDocs(properties: Record<string, SchemaProperty>, depth: number = 0): string {
  if (!properties) return '';
  
  let docs = '';
  const indent = '  '.repeat(depth);
  
  Object.entries(properties).forEach(([name, prop]) => {
    docs += `${indent}- \`${name}\`: ${prop.description || 'No description'}\n`;
    
    if (prop.enum) {
      docs += `${indent}  - Allowed values: ${prop.enum.join(', ')}\n`;
    }
    
    if (prop.default !== undefined) {
      docs += `${indent}  - Default: \`${JSON.stringify(prop.default)}\`\n`;
    }
    
    // Recurse for nested properties
    if (prop.properties) {
      docs += `${indent}  - Properties:\n`;
      docs += createNestedPropertyDocs(prop.properties, depth + 2);
    }
    
    // Document array items
    if (prop.type === 'array' && prop.items) {
      docs += `${indent}  - Array items:\n`;
      if (prop.items.properties) {
        docs += createNestedPropertyDocs(prop.items.properties, depth + 2);
      } else {
        docs += `${indent}    - Type: \`${prop.items.type || 'any'}\`\n`;
      }
    }
  });
  
  return docs;
}

// Main function to process tools and create markdown
function generateMarkdownDocs(tools: Tool[]): void {
  // Create docs directory if it doesn't exist
  const docsDir = path.join(process.cwd(), 'docs');
  if (!fs.existsSync(docsDir)) {
    fs.mkdirSync(docsDir);
  }
  
  // Group tools by category
  const toolCategories: Record<string, Tool[]> = {
    campaign: [],
    adSet: [],
    ad: [],
    account: [],
    other: []
  };
  
  tools.forEach(tool => {
    if (tool.name.includes('Campaign')) {
      toolCategories.campaign.push(tool);
    } else if (tool.name.includes('AdSet')) {
      toolCategories.adSet.push(tool);
    } else if (tool.name.includes('Ad') && !tool.name.includes('AdSet') && !tool.name.includes('Account')) {
      toolCategories.ad.push(tool);
    } else if (tool.name.includes('Account')) {
      toolCategories.account.push(tool);
    } else {
      toolCategories.other.push(tool);
    }
  });
  
  // Generate an index file
  let indexContent = '# Meta MCP Tool Documentation\n\n';
  indexContent += 'This documentation is automatically generated from TypeScript types using the docgen utility.\n\n';
  indexContent += '## Tool Categories\n\n';
  indexContent += '- [Campaigns](./tools-campaign.md)\n';
  indexContent += '- [Ad Sets](./tools-adset.md)\n';
  indexContent += '- [Ads](./tools-ad.md)\n';
  indexContent += '- [Ad Accounts](./tools-account.md)\n';
  
  if (toolCategories.other.length > 0) {
    indexContent += '- [Other Tools](./tools-other.md)\n';
  }
  
  fs.writeFileSync(path.join(docsDir, 'tools-index.md'), indexContent);
  
  // Generate documentation for each category
  generateCategoryDoc('Campaign', toolCategories.campaign, path.join(docsDir, 'tools-campaign.md'));
  generateCategoryDoc('Ad Set', toolCategories.adSet, path.join(docsDir, 'tools-adset.md'));
  generateCategoryDoc('Ad', toolCategories.ad, path.join(docsDir, 'tools-ad.md'));
  generateCategoryDoc('Ad Account', toolCategories.account, path.join(docsDir, 'tools-account.md'));
  
  if (toolCategories.other.length > 0) {
    generateCategoryDoc('Other', toolCategories.other, path.join(docsDir, 'tools-other.md'));
  }
  
  console.log('Markdown documentation generated successfully');
}

// Helper function to generate a category documentation file
function generateCategoryDoc(categoryName: string, tools: Tool[], outputPath: string): void {
  let content = `# ${categoryName} Tools\n\n`;
  content += 'These tools allow you to interact with Facebook Marketing API ' + 
    categoryName.toLowerCase() + ' resources.\n\n';
  
  content += '## Table of Contents\n\n';
  tools.forEach(tool => {
    const anchor = tool.name.toLowerCase();
    content += `- [${tool.name}](#${anchor})\n`;
  });
  
  content += '\n---\n\n';
  
  // Document each tool
  tools.forEach((tool, index) => {
    content += `## ${tool.name}\n\n`;
    content += `${tool.description}\n\n`;
    
    content += '### Parameters\n\n';
    if (tool.inputSchema.properties) {
      content += createSchemaTable(tool.inputSchema.properties, tool.inputSchema.required || []);
      
      // Document nested properties for complex parameters
      const complexParams = Object.entries(tool.inputSchema.properties)
        .filter(([_, prop]) => prop.type === 'object' && prop.properties);
      
      if (complexParams.length > 0) {
        content += '\n### Parameter Details\n\n';
        
        complexParams.forEach(([name, prop]) => {
          content += `#### \`${name}\` Properties\n\n`;
          if (prop.properties) {
            content += createNestedPropertyDocs(prop.properties);
          }
        });
      }
    } else {
      content += 'No parameters required.\n';
    }
    
    content += '\n### Example\n\n';
    content += '```javascript\n';
    
    // Generate example code based on tool name
    if (tool.name.startsWith('create')) {
      const configParam = tool.inputSchema.properties?.config ? ', { config: { ... } }' : '';
      content += `const result = await mcp.call('meta-mcp.${tool.name}'${configParam});\n`;
      content += `console.log(\`Created with ID: \${result.id}\`);\n`;
    } else if (tool.name.startsWith('get')) {
      const entity = tool.name.replace('get', '');
      const idParam = Object.entries(tool.inputSchema.properties || {})
        .find(([name, _]) => name.includes('Id'));
      
      if (idParam) {
        content += `const ${entity.toLowerCase()} = await mcp.call('meta-mcp.${tool.name}', { ${idParam[0]}: '123456789' });\n`;
        content += `console.log(${entity.toLowerCase()});\n`;
      } else {
        content += `const result = await mcp.call('meta-mcp.${tool.name}');\n`;
        content += `console.log(result);\n`;
      }
    } else if (tool.name.startsWith('pause') || tool.name.startsWith('update')) {
      const idParam = Object.entries(tool.inputSchema.properties || {})
        .find(([name, _]) => name.includes('Id'));
      
      if (idParam) {
        const additionalParams = tool.name.startsWith('update') ? ', config: { ... }' : '';
        content += `const success = await mcp.call('meta-mcp.${tool.name}', { ${idParam[0]}: '123456789'${additionalParams} });\n`;
        content += `console.log(\`Operation ${tool.name.startsWith('update') ? 'update' : 'pause'} successful\`);\n`;
      }
    } else {
      content += `const result = await mcp.call('meta-mcp.${tool.name}');\n`;
      content += `console.log(result);\n`;
    }
    
    content += '```\n';
    
    // Add separator between tools
    if (index < tools.length - 1) {
      content += '\n---\n\n';
    }
  });
  
  fs.writeFileSync(outputPath, content);
}

// Main execution
try {
  // Read the tools.json file
  const toolsPath = path.join(process.cwd(), 'docs', 'tools.json');
  
  if (!fs.existsSync(toolsPath)) {
    console.error('Error: tools.json not found. Run npm run generate-docs -- --file first.');
    process.exit(1);
  }
  
  const tools = JSON.parse(fs.readFileSync(toolsPath, 'utf8')) as Tool[];
  generateMarkdownDocs(tools);
} catch (error) {
  console.error('Error generating markdown documentation:', error);
  process.exit(1);
} 